;;; ai-code-autoloads.el --- automatically extracted autoloads (do not edit)   -*- lexical-binding: t -*-
;; Generated by the `loaddefs-generate' function.

;; This file is part of GNU Emacs.

;;; Code:

(add-to-list 'load-path (or (and load-file-name (directory-file-name (file-name-directory load-file-name))) (car load-path)))



;;; Generated autoloads from ai-code.el

(defvar ai-code-use-gptel-headline nil "\
Whether to use GPTel to generate headlines for prompt sections.
If non-nil, call `gptel-get-answer` from gptel-assistant.el to generate
headlines instead of using the current time string.")
(custom-autoload 'ai-code-use-gptel-headline "ai-code" t)
(defvar ai-code-prompt-suffix nil "\
Suffix text to append to prompts after a new line.
If non-nil, this text will be appended to the end of each prompt
with a newline separator.")
(custom-autoload 'ai-code-prompt-suffix "ai-code" t)
(defvar ai-code-cli "claude" "\
The command-line AI tool to use for `ai-code-apply-prompt-on-current-file`.")
(custom-autoload 'ai-code-cli "ai-code" t)
(autoload 'ai-code-send-command "ai-code" "\
Read a prompt from the user and send it to the AI service.
With a prefix argument (\\[universal-argument]), append the clipboard
contents as context.
ARG is the prefix argument.

(fn ARG)" t)
(autoload 'ai-code-cli-switch-to-buffer-or-hide "ai-code" "\
Hide current buffer if its name starts and ends with '*'.
Otherwise switch to AI CLI buffer." t)
(autoload 'ai-code-menu "ai-code" "\
Transient menu for AI Code Interface interactive functions.

(fn)" t)
(autoload 'ai-code-evil-setup "ai-code" "\
Setup AI Code integration with Evil mode.
This function configures SPC key binding in Evil normal state for
special AI Code buffers.  Call this function after Evil is loaded,
typically in your Emacs configuration with:
  (with-eval-after-load \\='evil (ai-code-evil-setup))" t)
(register-definition-prefixes "ai-code" '("ai-code-"))


;;; Generated autoloads from ai-code-agile.el

(autoload 'ai-code-refactor-book-method "ai-code-agile" "\
Apply refactoring techniques or request suggestions.
Uses current context (function, class, selected region).
If TDD-MODE is non-nil, adjusts prompts and instructions for the
TDD refactor stage.

(fn &optional TDD-MODE)" t)
(autoload 'ai-code-run-test "ai-code-agile" "\
Run tests based on the current buffer's mode.
Checks for specific test runners (python-pytest, jest, ert) and runs
them if available." t)
(autoload 'ai-code-tdd-cycle "ai-code-agile" "\
Guide through Test Driven Development cycle (Red-Green-Refactor).
Helps users follow Kent Beck's TDD methodology with AI assistance.
Works with both source code and test files that have been added to ai-code." t)
(register-definition-prefixes "ai-code-agile" '("ai-code--"))


;;; Generated autoloads from ai-code-ai.el

(autoload 'ai-code-debug-mcp "ai-code-ai" "\
Debug MCP by choosing to run mcp, inspector, or generate a config.
If current buffer is a python file, ask user to choose either
\\='Run mcp\\=', \\='Run inspector\\=', \\='Open inspector.sh\\=',
or \\='Generate mcp config\\=', and call the matching helper." t)
(autoload 'ai-code-mcp-generate-config "ai-code-ai" "\
Generate an MCP config snippet tailored for the active backend.
Claude-oriented backends receive JSON, while the Codex backend outputs toml.
The snippet is shown in *<base-dir-name>:mcp config*." t)
(autoload 'ai-code-mcp-run "ai-code-ai" "\
Run python mcp with uv command.
Run command: uv --directory PROJECT-ROOT-BASE-DIR run
RELATIVE-PATH-TO-CURRENT-BUFFER-FILE.
Execute in compilation buffer named
*ai-code-mcp-run:FULL-PATH-OF-PYTHON-FILE*.
If current buffer is not a python file, message user and quit." t)
(autoload 'ai-code-mcp-open-inspector-script "ai-code-ai" "\
Open inspector.sh file in other window.
First find project root with `ai-code-mcp-inspector--find-project-root',
then open inspector.sh in the project root.
If the file does not exist, still open it and show message in minibuffer." t)
(autoload 'ai-code-mcp-inspector-run "ai-code-ai" "\
Run MCP inspector for the current context.
If inspector.sh is found in an ancestor directory, use that directory as
working directory and run it with bash.
Otherwise, for Python buffers, locate the project root via pyproject.toml and
run the inspector against the active file. For Dired buffers, prompt for an
inspector command, prefix the required ports, and execute it inside the listed
directory." t)
(register-definition-prefixes "ai-code-ai" '("ai-code-"))


;;; Generated autoloads from ai-code-backends.el

(autoload 'ai-code-cli-resume "ai-code-backends" "\
Resume the current backend's CLI session when supported.
Argument ARG is passed to the backend's resume function.

(fn &optional ARG)" t)
(autoload 'ai-code-claude-code-send-command "ai-code-backends" "\
Send CMD to claude-code programmatically or interactively.
This wrapper function works around the signature change in
`claude-code-send-command' which no longer accepts a command parameter.
When called interactively, prompts for the command.
When called from Lisp code, sends CMD directly without prompting.

(fn CMD)" t)
(defvar ai-code-backends '((claude-code :label "claude-code.el" :require claude-code :start claude-code :switch claude-code-switch-to-buffer :send ai-code-claude-code-send-command :resume claude-code-resume :config "~/.claude.json" :upgrade "npm install -g @anthropic-ai/claude-code@latest" :cli "claude") (claude-code-ide :label "claude-code-ide.el" :require claude-code-ide :start claude-code-ide--start-if-no-session :switch claude-code-ide-switch-to-buffer :send claude-code-ide-send-prompt :resume claude-code-ide-resume :config "~/.claude.json" :upgrade "npm install -g @anthropic-ai/claude-code@latest" :cli "claude") (gemini :label "Gemini CLI" :require gemini-cli :start gemini-cli :switch gemini-cli-switch-to-buffer :send gemini-cli--do-send-command :resume gemini-cli-resume :config "~/.gemini/settings.json" :upgrade "npm install -g @google/gemini-cli" :cli "gemini") (github-copilot-cli :label "GitHub Copilot CLI" :require ai-code-github-copilot-cli :start ai-code-github-copilot-cli :switch ai-code-github-copilot-cli-switch-to-buffer :send ai-code-github-copilot-cli-send-command :resume ai-code-github-copilot-cli-resume :config "~/.copilot/mcp-config.json" :upgrade "npm install -g @github/copilot" :cli "copilot") (codex :label "OpenAI Codex CLI" :require ai-code-codex-cli :start ai-code-codex-cli :switch ai-code-codex-cli-switch-to-buffer :send ai-code-codex-cli-send-command :resume ai-code-codex-cli-resume :config "~/.codex/config.toml" :upgrade "npm install -g @openai/codex@latest" :cli "codex") (opencode :label "Opencode" :require ai-code-opencode :start ai-code-opencode :switch ai-code-opencode-switch-to-buffer :send ai-code-opencode-send-command :resume ai-code-opencode-resume :config "~/.config/opencode/opencode.jsonc" :upgrade "npm i -g opencode-ai@latest" :cli "opencode") (grok :label "Grok CLI" :require ai-code-grok-cli :start ai-code-grok-cli :switch ai-code-grok-cli-switch-to-buffer :send ai-code-grok-cli-send-command :resume ai-code-grok-cli-resume :config "~/.config/grok/config.json" :upgrade "bun add -g @vibe-kit/grok-cli" :cli "grok")) "\
Available AI backends and how to integrate with them.
Each entry is (KEY :label STRING :require FEATURE :start FN :switch FN
:send FN :resume FN-or-nil :upgrade STRING-or-nil :cli STRING).
The :upgrade property can be either a string shell command or nil.")
(custom-autoload 'ai-code-backends "ai-code-backends" t)
(autoload 'ai-code-cli-start-or-resume "ai-code-backends" "\
Start or resume the CLI depending on prefix argument.
If called with \\[universal-argument] (raw prefix ARG \\='(4)),
invoke `ai-code-cli-resume'; otherwise call `ai-code-cli-start'.

(fn &optional ARG)" t)
(autoload 'ai-code-select-backend "ai-code-backends" "\
Interactively select and apply an AI backend from `ai-code-backends'." t)
(autoload 'ai-code-open-backend-config "ai-code-backends" "\
Open the current backend's configuration file in another window." t)
(autoload 'ai-code-upgrade-backend "ai-code-backends" "\
Run the upgrade command for the currently selected backend." t)
(register-definition-prefixes "ai-code-backends" '("ai-code-"))


;;; Generated autoloads from ai-code-change.el

(autoload 'ai-code-code-change "ai-code-change" "\
Generate prompt to change code under cursor or in selected region.
If the cursor is on a TODO comment or a region with a TODO comment is
selected, it will generate a prompt to implement the TODO in-place.
With a prefix argument [universal-argument], append the clipboard
contents as context.  If a region is selected, change that specific
region.  Otherwise, change the function under cursor.  If nothing is
selected and no function context, prompts for general code change.
Inserts the prompt into the AI prompt file and optionally sends to AI.
Argument ARG is the prefix argument.

(fn ARG)" t)
(autoload 'ai-code-implement-todo "ai-code-change" "\
Generate prompt to implement TODO comments in current context.
Implements code after TODO comments instead of replacing them in-place.
With a prefix argument \\[universal-argument], append the clipboard
contents as context.  If region is selected, implement that specific
region.  If cursor is on a comment line, implement that specific comment.
If the current line is blank, ask user to input TODO comment.
The input string will be prefixed with TODO: and insert to the current
line, with proper indentation.  If cursor is inside a function, implement
comments for that function.
Otherwise implement comments for the entire current file.
Argument ARG is the prefix argument.

(fn ARG)" t)
(autoload 'ai-code-flycheck-fix-errors-in-scope "ai-code-change" "\
Ask AI to generate a patch fixing Flycheck errors.
If a region is active, operate on that region.
Otherwise prompt to choose scope: current line, current function (if any),
or whole file.  Requires the `flycheck` package to be installed and available." t)
(register-definition-prefixes "ai-code-change" '("ai-code-"))


;;; Generated autoloads from ai-code-codex-cli.el

(autoload 'ai-code-codex-cli "ai-code-codex-cli" "\
Start Codex (reuses `claude-code' startup logic).
ARG is passed to `claude-code'.

(fn &optional ARG)" t)
(autoload 'ai-code-codex-cli-switch-to-buffer "ai-code-codex-cli" "\
Switch to the Codex CLI buffer." t)
(autoload 'ai-code-codex-cli-send-command "ai-code-codex-cli" "\
Send LINE to Codex CLI programmatically or interactively.
When called interactively, prompts for the command.
When called from Lisp code, sends LINE directly without prompting.

(fn LINE)" t)
(autoload 'ai-code-codex-cli-resume "ai-code-codex-cli" "\
Resume a previous Codex CLI session.
ARG is passed to the underlying start function.

(fn &optional ARG)" t)
(register-definition-prefixes "ai-code-codex-cli" '("ai-code-codex-cli-program"))


;;; Generated autoloads from ai-code-discussion.el

(autoload 'ai-code-ask-question "ai-code-discussion" "\
Generate prompt to ask questions about specific code.
With a prefix argument [universal-argument], append the clipboard
contents as context.  If current buffer is a file, keep existing logic.
If current buffer is a Dired buffer:
  - If there are files or directories marked, use them as context
    (use git repo relative path, start with @ character)
  - If there are no files or dirs marked, but under cursor there is
    file or dir, use it as context of prompt
If a region is selected, ask about that specific region.
If cursor is in a function, ask about that function.
Otherwise, ask a general question about the file.
Inserts the prompt into the AI prompt file and optionally sends to AI.

Argument ARG is the prefix argument.

(fn ARG)" t)
(autoload 'ai-code-investigate-exception "ai-code-discussion" "\
Generate prompt to investigate exceptions or errors in code.
With a prefix argument [universal-argument], use context from clipboard
as the error to investigate.  If a *compilation* buffer is visible in
the current window, use its full content as context.  If a region is
selected, investigate that specific error or exception.  If cursor is
in a function, investigate exceptions in that function.  Otherwise,
investigate general exception handling in the file.  Inserts the prompt
into the AI prompt file and optionally sends to AI.
Argument ARG is the prefix argument.

(fn ARG)" t)
(autoload 'ai-code-explain "ai-code-discussion" "\
Generate prompt to explain code at different levels.
If current buffer is a Dired buffer and under cursor is a directory or
file, explain that directory or file using relative path as context
(start with @ character).  If a region is selected, explain that
specific region using function/file as context.  Otherwise, prompt user
to select scope: symbol, line, function, or file.  Inserts the prompt
into the AI prompt file and optionally sends to AI." t)
(defvar ai-code-notes-file-name ".ai.code.notes.org" "\
Default note file name relative to the project root.
This value is used by `ai-code-take-notes' when suggesting where to store notes.")
(custom-autoload 'ai-code-notes-file-name "ai-code-discussion" t)
(defvar ai-code-notes-use-gptel-headline nil "\
Whether to use GPTel to generate headline for notes.
If non-nil, call `ai-code-call-gptel-sync` to generate a smart default
headline based on the selected content. Otherwise, prompt with empty default.")
(custom-autoload 'ai-code-notes-use-gptel-headline "ai-code-discussion" t)
(autoload 'ai-code-take-notes "ai-code-discussion" "\
Take notes from selected region and save to a note file.
When there is a selected region, prompt to select from currently open
org buffers or the default note file path (.ai.code.notes.org in the
git root).  Add the section title as a headline at the end of the note
file, and put the selected region as content of that section." t)
(register-definition-prefixes "ai-code-discussion" '("ai-code--"))


;;; Generated autoloads from ai-code-file.el

(autoload 'ai-code-copy-buffer-file-name-to-clipboard "ai-code-file" "\
Copy the current buffer's file path or selected text to clipboard.
If in a magit status buffer, copy the current branch name.
If in a Dired buffer, copy the file at point or directory path.
If in a regular file buffer with selected text, copy text with file path.
Otherwise, copy the file path of the current buffer.
With prefix argument ARG [universal-argument], always return full path
instead of processed path.  File paths are processed to relative paths
with @ prefix if within git repo.

(fn &optional ARG)" t)
(autoload 'ai-code-open-clipboard-file-path-as-dired "ai-code-file" "\
Open the file or directory path from clipboard in Dired.
If the clipboard contains a valid file path, open its directory in Dired
in another window and move the cursor to that file.  If the clipboard
contains a directory path, open it directly in Dired in another window." t)
(autoload 'ai-code-run-current-file "ai-code-file" "\
Generate command to run current script file (.py, .js, .ts, or .sh).
Let user modify the command before running it in a comint buffer.
Maintains a dedicated history list for this command." t)
(autoload 'ai-code-apply-prompt-on-current-file "ai-code-file" "\
Apply a user prompt to the current file and send to an AI CLI tool.
The file can be the one in the current buffer or at point in a Dired
buffer.  It constructs a shell command:
sed \"1i <prompt>: \" <file> | <ai-code-cli>
and runs it in a compilation buffer." t)
(autoload 'ai-code-shell-cmd "ai-code-file" "\
Run shell command in Dired directory or insert command in shell buffers.
If current buffer is a Dired buffer, get user input shell command with
`read-string', then run it under the directory of Dired buffer, in a
buffer with name as *ai-code-shell-cmd: <current-dir>*.  If current
buffer is `shell-mode', `eshell-mode' or `sh-mode', get input and insert
command under cursor, do not run it.  If the command starts with
\\=':\\=', it means it is a prompt.  In this case, ask gptel to generate
the corresponding shell command, and call `ai-code-shell-cmd' with that
command as candidate.  INITIAL-INPUT is the initial text to populate the
shell command prompt.

(fn &optional INITIAL-INPUT)" t)
(autoload 'ai-code-run-current-file-or-shell-cmd "ai-code-file" "\
Run current file or shell command based on buffer state.
Call `ai-code-shell-cmd` when in Dired mode, shell modes or a region
is active; otherwise run the current file." t)
(autoload 'ai-code-add-context "ai-code-file" "\
Capture current buffer context and store it per Git repository.
When no region is selected, use the full file path and current function
(if any).  When a region is active, use the file path with line range
in the form filepath#Lstart-Lend." t)
(autoload 'ai-code-toggle-current-buffer-dedicated "ai-code-file" "\
Toggle the dedicated state of the current buffer's window.
When a window is dedicated, Emacs will not automatically reuse it for
displaying other buffers.  With prefix ARG [universal-argument],
toggle dedication for every window in the current frame.

(fn ARG)" t)
(register-definition-prefixes "ai-code-file" '("ai-code-"))


;;; Generated autoloads from ai-code-git.el

(autoload 'ai-code-pull-or-review-diff-file "ai-code-git" "\
Review a diff file with AI Code or generate one if not viewing a diff.
If current buffer is a .diff file, ask AI Code to review it.
Otherwise, generate the diff." t)
(autoload 'ai-code-magit-blame-analyze "ai-code-git" "\
Analyze current file or region Git history with AI for deeper insights.
If region is active, analyze just that region.  Otherwise analyze entire file.
Combines `magit-blame' history tracking with AI analysis to help understand
code evolution and the reasoning behind changes." t)
(autoload 'ai-code-magit-blame-or-log-analyze "ai-code-git" "\
If current buffer is git.log, run log analysis.
Otherwise if prefix ARG, run log analysis; else run blame analysis.
ARG is the prefix argument.

(fn &optional ARG)" t)
(autoload 'ai-code-magit-setup-transients "ai-code-git" "\
Configure AI Code's transient menu entries in Magit.
This function uses `with-eval-after-load` to ensure that the
Magit transients are modified only after Magit itself has been loaded.
Call this function to register the AI Code commands with Magit." t)
(autoload 'ai-code-init-project "ai-code-git" "\
Initialize project helpers for Projectile and Helm-Gtags.
If either package is available, prompt for a project directory
defaulting to the Magit repository root, initialize the project in
Projectile, and configure Helm-Gtags with a pygments label.  Show a
summary message of performed actions.
PREFIX is the prefix argument.

(fn PREFIX)" t)
(autoload 'ai-code-update-git-ignore "ai-code-git" "\
Ensure repository .gitignore contains AI Code related entries.
If not inside a Git repository, do nothing." t)
(register-definition-prefixes "ai-code-git" '("ai-code-"))


;;; Generated autoloads from ai-code-github-copilot-cli.el

(autoload 'ai-code-github-copilot-cli "ai-code-github-copilot-cli" "\
Start GitHub Copilot CLI (reuses `claude-code' startup logic).
ARG is passed to `claude-code'.

(fn &optional ARG)" t)
(autoload 'ai-code-github-copilot-cli-switch-to-buffer "ai-code-github-copilot-cli" "\
Switch to the GitHub Copilot CLI buffer." t)
(autoload 'ai-code-github-copilot-cli-send-command "ai-code-github-copilot-cli" "\
Send LINE to GitHub Copilot CLI programmatically or interactively.
When called interactively, prompts for the command.
When called from Lisp code, sends LINE directly without prompting.

(fn LINE)" t)
(autoload 'ai-code-github-copilot-cli-resume "ai-code-github-copilot-cli" "\
Resume a previous GitHub Copilot CLI session.

This command starts GitHub Copilot CLI with the --resume flag to resume
a specific past session. The CLI will present an interactive list of past
sessions to choose from.

If current buffer belongs to a project, start in the project's root
directory. Otherwise start in the directory of the current buffer file,
or the current value of `default-directory' if no project and no buffer file.

With double prefix ARG (\\[universal-argument] \\[universal-argument]),
prompt for the project directory.

(fn &optional ARG)" t)
(register-definition-prefixes "ai-code-github-copilot-cli" '("ai-code-github-copilot-cli-program"))


;;; Generated autoloads from ai-code-grok-cli.el

(autoload 'ai-code-grok-cli "ai-code-grok-cli" "\
Start Grok CLI by leveraging `claude-code'.
ARG is passed to `claude-code'.

(fn &optional ARG)" t)
(autoload 'ai-code-grok-cli-switch-to-buffer "ai-code-grok-cli" "\
Switch to the Grok CLI buffer." t)
(autoload 'ai-code-grok-cli-send-command "ai-code-grok-cli" "\
Send LINE to Grok CLI programmatically or interactively.
When called interactively, prompts for the command.
When called from Lisp code, sends LINE directly without prompting.

(fn LINE)" t)
(autoload 'ai-code-grok-cli-resume "ai-code-grok-cli" "\
Resume the previous Grok CLI session, when supported.
ARG is passed to the underlying start function.

(fn &optional ARG)" t)
(register-definition-prefixes "ai-code-grok-cli" '("ai-code-grok-cli-program"))


;;; Generated autoloads from ai-code-input.el

(autoload 'ai-code-plain-read-string "ai-code-input" "\
Read a string from the user with PROMPT and optional INITIAL-INPUT.
CANDIDATE-LIST provides additional completion options if provided.
This function combines candidate-list with history for better completion.

(fn PROMPT &optional INITIAL-INPUT CANDIDATE-LIST)")
(defalias 'ai-code-read-string #'ai-code-plain-read-string)
(if (featurep 'helm) (defalias 'ai-code-read-string #'ai-code-helm-read-string))
(autoload 'ai-code-insert-function-at-point "ai-code-input" "\
Insert a function name selected from current windows' prog-mode buffers." t)
(register-definition-prefixes "ai-code-input" '("ai-code-"))


;;; Generated autoloads from ai-code-opencode.el

(autoload 'ai-code-opencode "ai-code-opencode" "\
Start Opencode (reuses `claude-code' startup logic).
ARG is passed to `claude-code'.

(fn &optional ARG)" t)
(autoload 'ai-code-opencode-switch-to-buffer "ai-code-opencode" "\
Switch to the Opencode buffer." t)
(autoload 'ai-code-opencode-send-command "ai-code-opencode" "\
Send LINE to Opencode.
When called interactively, prompts for the command.

(fn LINE)" t)
(autoload 'ai-code-opencode-resume "ai-code-opencode" "\
Resume a previous Opencode session.

This command starts Opencode with the --resume flag to resume
a specific past session. The CLI will present an interactive list of past
sessions to choose from.

If current buffer belongs to a project, start in the project's root
directory. Otherwise start in the directory of the current buffer file,
or the current value of `default-directory' if no project and no buffer file.

With double prefix ARG (\\[universal-argument] \\[universal-argument]),
prompt for the project directory.

(fn &optional ARG)" t)
(register-definition-prefixes "ai-code-opencode" '("ai-code-opencode-program"))


;;; Generated autoloads from ai-code-prompt-mode.el

(defvar ai-code-prompt-file-name ".ai.code.prompt.org" "\
File name that will automatically enable `ai-code-prompt-mode` when opened.
This is the file name without path.")
(custom-autoload 'ai-code-prompt-file-name "ai-code-prompt-mode" t)
(autoload 'ai-code-open-prompt-file "ai-code-prompt-mode" "\
Open AI prompt file under git repo root.
If file doesn't exist, create it with sample prompt." t)
(autoload 'ai-code-prompt-mode "ai-code-prompt-mode" "\
Major mode derived from `org-mode` for editing AI prompt files.
Special commands:
{ai-code-prompt-mode-map}

(fn)" t)
(autoload 'ai-code-prompt-send-block "ai-code-prompt-mode" "\
Send the current text block (paragraph) to the AI service.
The block is the text separated by blank lines.
It trims leading/trailing whitespace." t)
(add-to-list 'auto-mode-alist `(,(concat "/" (regexp-quote ai-code-prompt-file-name) "'") . ai-code-prompt-mode))
(register-definition-prefixes "ai-code-prompt-mode" '("ai-code-"))

;;; End of scraped data

(provide 'ai-code-autoloads)

;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; no-native-compile: t
;; coding: utf-8-emacs-unix
;; End:

;;; ai-code-autoloads.el ends here
